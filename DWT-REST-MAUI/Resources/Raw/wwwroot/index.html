<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DDV - HelloWorld</title>
    <link rel="stylesheet" href="ddv/ddv.css">
    <script src="ddv/ddv.js"></script>
</head>
<style>
    html,body {
        width: 100%;
        height: 100%;
        margin:0;
        padding:0;
        overscroll-behavior-y: none;
        overflow: hidden;
    }

    #container {
        width: 100%;
        height: 96%;
    }
</style>
<body>
    <div id="container"></div>
    <select id="sources">
    </select>
    <!--<input type="button" value="GetScanners" onclick="getSources();"/>
    <input type="button" value="Scan Image" onclick="acquireImageFromScanner();"/>-->
    <input type="button" value="Capture Image" onclick="acquireImageFromCamera();" />
    <!--<input type="button" value="Read barcode" onclick="scanBarcode();" />-->
    <input type="button" value="Save to pdf" onclick="onClickSaveToPdf();" />
</body>
<script>
    // call .net
    // Unified function to send messages to .NET
    function sendMessageToDotNet(message) {
        try { 
            message = (messageType === '') ? message : `${messageType}|${message}`;
            if (window.chrome && window.chrome.webview) {
                // For WinForms and WPF (WebView2)
                window.chrome.webview.postMessage(message);
            }
            else if (window.DotNet) {
                // For Blazor, not sure if this is the right way
                DotNet.invokeMethodAsync(blazorAppName, blazorCallbackName, message);
            }
            else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.webwindowinterop) {
                // iOS and MacCatalyst WKWebView
                window.webkit.messageHandlers.webwindowinterop.postMessage(message);
            }
            else if (hybridWebViewHost){
                // Android WebView
                hybridWebViewHost.sendMessage(message);
            }
            else {
                console.error("Unsupported platform or WebView environment.");
            }
        }
        catch (error) {
            console.error("Error sending message to .NET:", error);
        }
    };

    window.addEventListener("load", function () {
        const message = {
            name: 'load'
        }
        messageType = '__RawMessage';
        console.log(message);
        sendMessageToDotNet(JSON.stringify([message, "true"]));
    });
    // call .net

    // call from .net
    var productkey;
    var messageType;
    async function initView(options) {
        console.log(options);
        let name = '';
        try {
            const op = JSON.parse(options);
            console.log(op.productKey);
            productkey = op.productKey;
            name = op.name;
            messageType = op.messageType;
        //    protocol = JSON.parse(op.protocol);
        //    console.log(protocol);
        //    console.log(protocol.webviewuid);
        //    if (protocol) {
        //        restServer = protocol.websocket.server;
        //    }
        }
        catch (error) {
            console.log(error);
        }

        // Public trial license which is valid for 24 hours
        // You can request a 30-day trial key from https://www.dynamsoft.com/customer/license/trialLicense/?product=mwc
        Dynamsoft.DDV.Core.license = productkey ?? "DLS2eyJoYW5kc2hha2VDb2RlIjoiMTAwMjI3NzYzLVRYbFFjbTlxIiwibWFpblNlcnZlclVSTCI6Imh0dHBzOi8vbWx0cy5keW5hbXNvZnQuY29tIiwib3JnYW5pemF0aW9uSUQiOiIxMDAyMjc3NjMiLCJzdGFuZGJ5U2VydmVyVVJMIjoiaHR0cHM6Ly9zbHRzLmR5bmFtc29mdC5jb20iLCJjaGVja0NvZGUiOjE4OTc4MDUzNDV9";
        //Dynamsoft.DDV.Core.engineResourcePath = "engine";
        // Preload DDV Resource
        Dynamsoft.DDV.Core.loadWasm();
        await Dynamsoft.DDV.Core.init();
        Dynamsoft.DDV.setProcessingHandler("imageFilter", new Dynamsoft.DDV.ImageFilter());
        const editViewer = new Dynamsoft.DDV.EditViewer({
            container: "container",
            uiConfig: Dynamsoft.DDV.getDefaultUiConfig("editViewer", { includeAnnotationSet: true }),
        });
        window["editViewer"] = editViewer;

        // send back to .net
        const result = [{
            name: name,
        }, location.origin]
        sendMessageToDotNet(JSON.stringify(result));
    }

    function createNewDocument() {
        editViewer.closeDocument();
        let doc = Dynamsoft.DDV.documentManager.createDocument();
        editViewer.openDocument(doc.uid);
    }

    function base64toBlob(base64Data, contentType = '', sliceSize = 512) {
        const byteCharacters = atob(base64Data);
        const byteArrays = [];

        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);

            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }

            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }

        const blob = new Blob(byteArrays, { type: contentType });
        return blob;
    }

    async function loadImage(base64Image) {
        try {
            if (editViewer) {
                let doc = makesureDocOpened();
                await doc.loadSource(base64toBlob(base64Image));
            }
        } catch (error) {
            console.error('Error loading document:', error);
        } finally {
        }
    }

    async function loadDocument(url, callback) {
        console.log(url);
        
        try {
            const response = await fetch(url, {
                method: "GET"
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const image = await response.arrayBuffer();
            if (editViewer) {
                let doc = makesureDocOpened();
                await doc.loadSource(new Blob([image], { type: response.headers.get("content-type") }));
            }
        } catch (error) {
            console.error('Error loading document:', error);
        } finally {
            // send back to .net
            sendMessageToDotNet(callback);
        }
    }

    function stringToBase64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    };

    async function fileToBase64 (file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]); // Extract Base64 part
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(file);
        });
        };

    async function onClickSaveToPdf() {
        const result = await savetopdfInner();
        result[0].name = onClickSaveToPdf.name; // call from js, so the name is the function name
        sendMessageToDotNet(JSON.stringify(result));
    }

    async function saveToPdf(name) {
        const result = await savetopdfInner();
        result[0].name = name; // call from .net, the name is the different for .net code to receive result
        sendMessageToDotNet(JSON.stringify(result));
    }

    async function savetopdfInner() {
        let message = {
            name: ''
        };
        let result = "";
        try {
            let response = await saveAsPdf();
            if (!response && Dynamsoft.DDV.lastError) {
                response = Dynamsoft.DDV.lastError.cause;
            }
            if (response instanceof Blob) {
                result = await fileToBase64(response);
            }
            else {
                message.cause = response;
            }
        }
        catch (error) {
            let response = error.cause ?? JSON.stringify(error, Object.getOwnPropertyNames(error));
            message.cause = response;
        }

        return [message, result];
    }


    // call from .net

function makesureDocOpened() {
    let doc = editViewer.currentDocument;
    if (!doc) {
        doc = Dynamsoft.DDV.documentManager.createDocument();
        editViewer.openDocument(doc.uid);
    }
    return doc;
    }


    //async function runScript(request) {
    //    try {
    //        if (request.script) {
    //            let response = await eval(request.script);
    //            if (!response && Dynamsoft.DDV.lastError) {
    //                response = Dynamsoft.DDV.lastError.cause;
    //            }
    //            if (response instanceof Blob) {
    //                await fetch(request.callback.url, {
    //                    method: request.callback.method,
    //                    body: response
    //                });
    //            }
    //            else {
    //                await fetch(request.callback.url, {
    //                    method: request.callback.method,
    //                    body: JSON.stringify(response)
    //                });
    //            }
    //        }
    //        // result can be null
    //    }
    //    catch (error) {
    //        const result = error.cause ?? JSON.stringify(error, Object.getOwnPropertyNames(error));
    //        await fetch(request.callback.url, {
    //            method: request.callback.method,
    //            body: JSON.stringify(result)
    //        });
    //    }
    //}

//    // Create a new WebSocket connection
//    const socket = new WebSocket(protocol.websocket.server, protocol.websocket.protocol); // Replace with your server URL

//    // Event listener for when the connection is opened
//    socket.addEventListener('open', (event) => {
//        console.log('WebSocket connection opened');

//        // Send a message to the server
//        socket.send(JSON.stringify(protocol.websocket.response));//`{"webviewuid": "${webviewuid}", "method": "rest.ws.init"}`); 
//    });


//async function handleEvent(request) {
//    console.log(request.evt);
//    const wsResponse = request.websocket.response;
//    try {
//        if (request.callback) {
//            const response = await fetch(request.callback.url, {
//                method: request.callback.method
//            }); 
//            const image = await response.arrayBuffer();
//            if (editViewer)
//            {
//                let doc = makesureDocOpened();
//                wsResponse.result = await doc.loadSource(new Blob([image], {type: response.headers.get("content-type")}));
//            }
//        }
//    }
//    catch (error) {
//        wsResponse.result = error.cause??JSON.stringify(error, Object.getOwnPropertyNames(error));
//    }   

//    socket.send(JSON.stringify(wsResponse));
//}

//// Event listener for incoming messages
//socket.addEventListener('message', (event) => {
//  console.log('Message from server:', event.data);
//  try {
//    const request = JSON.parse(event.data);
//    if (request.evt) {
//        handleEvent(request);
//    } 
//    else if (request.script) {
//        runScript(request);
//    }
//  }
//  catch(error) {
//      console.log(error);
//  }
//});

//// Event listener for errors
//socket.addEventListener('error', (event) => {
//  console.error('WebSocket error:', event);
//});

//// Event listener for when the connection is closed
//socket.addEventListener('close', (event) => {
//  console.log('WebSocket connection closed');
//});

function rotateLeft() {
    return editViewer.rotate(-90);
}

function rotateRight() {
    return editViewer.rotate(90);
}

async function saveAsPdf(indicies, settings) {
    if (editViewer.currentDocument) {
        if (indicies) {
            if (settings) {
                return await editViewer.currentDocument.saveToPdf(indicies, settings);
            }
            else {
                return await editViewer.currentDocument.saveToPdf(indicies);
            }
        }
        return await editViewer.currentDocument.saveToPdf();
    }
    else {
        return {code:-80304, message:"no document opened"};
    }
}

window.addEventListener('beforeunload', (event) => {
    event.preventDefault();
    event.returnValue = '';
});

async function clearAnnotations() {
    let currentDoc = editViewer.currentDocument;
    if (!currentDoc) {
        alert("Please load a document first.");
        return;
    }

    let currentPageId = currentDoc.pages[editViewer.getCurrentPageIndex()];
    let annotations = Dynamsoft.DDV.annotationManager.getAnnotationsByPage(currentPageId);

    if (annotations.length > 0) {
        for (let i = 0; i < annotations.length; i++) {
            // https://www.dynamsoft.com/document-viewer/docs/api/class/annotationmanager.html#deleteannotations

            if (!annotations[i].flattened && annotations[i].name !== 'barcode') {
                await Dynamsoft.DDV.annotationManager.deleteAnnotations([annotations[i].uid]);
            }
        }
    }
}

async function scanBarcode() {
    let docManager = Dynamsoft.DDV.documentManager;
    let docs = docManager.getAllDocuments();
    if (docs.length == 0) {
        alert("Please load a document first.");
        return;
    }

    let currentDoc = editViewer.currentDocument;

    // Save barcode annotations for detection
    const settings = {
        quality: 100,
        saveAnnotation: false,
    };

    let currentPageId = currentDoc.pages[editViewer.getCurrentPageIndex()];
    let annotations = Dynamsoft.DDV.annotationManager.getAnnotationsByPage(currentPageId);

    for (let i = 0; i < annotations.length; i++) {
        if (annotations[i].name === 'barcode') {
            annotations[i].flattened = true;
        }
    }
    const image = await editViewer.currentDocument.saveToJpeg(editViewer.getCurrentPageIndex(), settings);
    // saveBlob(image, "temp.jpg");
    //const result = await cvRouter.capture(image, "ReadBarcodes_ReadRateFirst"); // https://www.dynamsoft.com/capture-vision/docs/web/programming/javascript/api-reference/capture-vision-router/preset-templates.html?product=dbr&lang=javascript
    const results = await requestProcess(image, "temp.jpg", "ReadBarcodes_ReadRateFirst");

    // Undo the flattened status for barcode annotations
    for (let i = 0; i < annotations.length; i++) {
        if (annotations[i].name === 'barcode') {
            annotations[i].flattened = false;
        }
    }

    // clear annotations
    clearAnnotations();

    for (let result of results) {
        if (!result.barcodeResultItems) {
            alert("nothing found");
            return;
        }
        for (let item of result.barcodeResultItems) {
            //if (item.type !== Dynamsoft.Core.EnumCapturedResultItemType.CRIT_BARCODE) {
            //    continue;
            //}
            // console.log(JSON.stringify(item));
            let text = item.text;
            let points = item.location;//.points;

            let currentPageId = currentDoc.pages[editViewer.getCurrentPageIndex()];
            let pageData = await currentDoc.getPageData(currentPageId);

            // https://www.dynamsoft.com/document-viewer/docs/api/interface/annotationinterface/texttypewriterannotationoptions.html
            let textX = Math.min(points[0].x, points[1].x, points[2].x, points[3].x) / pageData.display.width * pageData.mediaBox.width;
            let textY = Math.min(points[0].y, points[1].y, points[2].y, points[3].y) / pageData.display.height * pageData.mediaBox.height;

            const textTypewriterOptions = {
                x: textX < 0 ? 0 : textX,
                y: textY - 15 < 0 ? 0 : textY - 15,
                textContents: [{ content: text, color: "rgb(255,0,0)" }],
                flags: {
                    print: false,
                    noView: false,
                    readOnly: true,

                }
            }

            // https://www.dynamsoft.com/document-viewer/docs/api/class/annotationmanager.html#createAnnotation
            let textTypewriter = await Dynamsoft.DDV.annotationManager.createAnnotation(currentPageId, "textTypewriter", textTypewriterOptions)
            textTypewriter['name'] = 'overlay';

            // https://www.dynamsoft.com/document-viewer/docs/api/interface/annotationinterface/polygonannotationoptions.html
            const polygonOptions = {
                points: points.map(p => {
                    return {
                        x: p.x / pageData.display.width * pageData.mediaBox.width,
                        y: p.y / pageData.display.height * pageData.mediaBox.height
                    }
                }),
                borderColor: "rgb(255,0,0)",
                flags: {
                    print: false,
                    noView: false,
                    readOnly: true,

                }
            }

            let polygon = Dynamsoft.DDV.annotationManager.createAnnotation(currentPageId, "polygon", polygonOptions);
            polygon['name'] = 'overlay';
        }
    }
}

function acquireImageFromCamera() {
    makesureDocOpened();
    const pcCaptureUiConfig = {
        type: Dynamsoft.DDV.Elements.Layout,
        flexDirection: "column",
        className: "ddv-capture-viewer-desktop",
        children: [
            {
                type: Dynamsoft.DDV.Elements.Layout,
                className: "ddv-capture-viewer-header-desktop",
                children: [
                    {
                        type: Dynamsoft.DDV.Elements.CameraResolution,
                        className: "ddv-capture-viewer-resolution-desktop",
                    },
                    Dynamsoft.DDV.Elements.AutoDetect,
                    {
                        type: Dynamsoft.DDV.Elements.Capture,
                        className: "ddv-capture-viewer-capture-desktop",
                    },
                    Dynamsoft.DDV.Elements.AutoCapture,
                    {
                    type: Dynamsoft.DDV.Elements.Button, 
                    className: "ddv-button-close position-button-close", // Set the button's icon
                    tooltip: "close viewer", // Set tooltip for the button
                    events: {
                        click: "close", // Set the click event
                    }, 
                    },
                ],
            },
            Dynamsoft.DDV.Elements.MainView,
            {
                type: Dynamsoft.DDV.Elements.ImagePreview,
                className: "ddv-capture-viewer-image-preview-desktop",
            },
        ],
    };

 
    editViewer.hide();
    const captureViewer = new Dynamsoft.DDV.CaptureViewer({
        container: "container",
        uiConfig: pcCaptureUiConfig
    });
    captureViewer.openDocument(editViewer.currentDocument.uid); // Open a document which has pages
    captureViewer.play();
    captureViewer.on("close"   , () => {
        captureViewer.destroy();
        editViewer.show();
    });
}
</script>
</html>
